%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\hp}
\label{sec:hephaestus}

\hp~\cite{rbonifacio:sbcars2009} is a
publicly\footnote{http://bit.ly/iRMMZM} available product derivation
tool~\cite{deelstra:2005}, which receives contributions from different
institutions (Federal University of Pernambuco, University of S\~{a}o
Paulo, University of Bras\'{i}lia).  Initially developed as a
proof-of-concept tool for managing variabilities in use case
scenarios~\cite{rbonifacio:aosd2009}, \hp{} provides a
declarative and executable specification in Haskell of a
compositional~\cite{kastner:2008} and parametric approach for managing
variability in use case scenarios.  Currently, \hp{} supports
variability in different types of assets, ranging from business
processes and Simulink models to source code; and it has been used as
the derivation tool in a industrial-strength product
line~\cite{ferreira:2010}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Initial \hp}
\label{S:initial-hp}

For the initial purpose of the tool, the implementation contained the
following entities:

\begin{itemize}
\item Specific data types representing use case model (UCM), feature
  model (FM), and configuration knowledge (CK) model~\cite{gpbook},
  which relates feature expressions in propositional logic to
  transformations that deal with variability in use cases.

\item Specific functions that solve SPL variabilities in use case
  scenarios, by selecting use cases or scenarios from an SPL model,
  composing them, and binding parameters according to specific feature
  configurations.

\item A \texttt{build} function that behaves like an interpreter for
  the configuration knowledge and is responsible for building a
  specific product given a selection of features, i.e., a feature
  configuration (FC).

\item Specific functions providing functionality on use case models.

\end{itemize}

Figure~\ref{fig:hephaestus-initial-code} presents a code snippet of
the initial implementation of \hp{}, highlighting data types
related to configuration knowledge (lines \ref{ck-i-1}-\ref{ck-f-1})
and a corresponding interpreter (the \texttt{build} function, in lines
\ref{build-i-1}-\ref{build-f-1}) and the signature of the
transformation functions (line \ref{transf-1}). The configuration
knowledge relates the problem space (through a feature expression) to
the solution space (through a list of asset transformations). Each
transformation solves a piece of variability in the SPL asset
base. The \texttt{build} function has four input artifacts (FM, FC,
CK, and SPL) and generates a product instance. The \textit{build}
process evaluates the rows of the CK, validating each feature
expression according to the FC--- the set of features that
characterizes a given product. If a feature expression of the CK is
true for the given FC, then the corresponding transformations are
applied to the generated product.  In addition, this code snippet also
shows the initial representation of the \texttt{SPLModel} (lines
\ref{splmodel-i-1}-\ref{splmodel-f-1}) and \texttt{InstanceModel}
(lines \ref{instancemodel-i-1}-\ref{instancemodel-f-1}) data
types. \texttt{SPLModel} collects artifacts whose variability management
addressed by the tool and their variability as described by the
feature model field, whereas \texttt{InstanceModel} collects assets after
a transformation reducing variability has been applied to
them. Eventually, all such variability is removed and the
\texttt{InstanceModel} value corresponds to the encompassed
configuration field. The \texttt{exportProduct} function (lines
\ref{exportP-i-1}-\ref{exportP-f-1}) generates a \LaTeX\
representation of a product-specific use case model.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
\begin{lstlisting}
type ConfigurationKnowledge = [ConfigurationItem] *'\label{ck-i-1}'*
data ConfigurationItem = ConfigurationItem {
  expression = FeatureExpression,
  transformations = [Transformation]
} *'\label{ck-f-1}'*

build :: FeatureModel *'\label{build-i-1}'*
      -> FeatureConfiguration
      -> ConfigurationKnowledge
      -> SPLModel
      -> InstanceModel
build fm fc ck spl = derive ts spl emptyInstance
where
    ts = concat [transformations c | c <- ck, eval fc (expression c)]
    ucmodel       = splUCM spl
    emptyUCM      = ucmodel { useCases = [] , aspects = [] }
    emptyInstance = InstanceModel fc emptyUCM *'\label{build-f-1}'*

derive [] spl product = product
derive (t:ts) spl product = derive ts spl (t spl product)

type Transformation = SPLModel -> InstanceModel -> InstanceModel *'\label{transf-1}'*

data SPLModel = SPLModel { *'\label{splmodel-i-1}'*
   splFeatureModel :: FeatureModel,
   splUCM :: UseCaseModel
} *'\label{splmodel-f-1}'*

data InstanceModel = InstanceModel { *'\label{instancemodel-i-1}'*
   featureConfiguration :: FeatureConfiguration,
   ucm :: UseCaseModel
} *'\label{instancemodel-f-1}'*

exportProduct :: Path -> InstanceModel -> IO () *'\label{exportP-i-1}'*
exportProduct t product = do
  exportUcmToLatex (t ++ ``/doc.tex'') (ucm product) *'\label{exportP-f-1}'*

exportUcmToLatex = ...
\end{lstlisting}
\caption{Code snippet of the initial implementation of \hp}
\label{fig:hephaestus-initial-code}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Ecolution of \hp} 
\label{hp-evolution}

In the context of a R\&D project, \hp{} was used as a replacement
for a proprietary tool that was used to manage variabilities in an
industrial-strength product line~\cite{ferreira:2010}, in which new
product assets should be exported as a consequence of the
\texttt{build} process. \hp{} thus evolved so that it could
manage variability not only in use case scenarios, but also in higher
level requirements and source code (by selecting specific files that
should be compiled as well as by starting a preprocessing engine to
solve variability in source code). We show the configuration of both
releases in Figures~\ref{fig:hephaestus-conf1a}
and~\ref{fig:hephaestus-conf1b}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure*}[bth]
\begin{center}
\includegraphics[scale=0.6]{imagens/conf1a-hp.png}
\caption{Configuration of \hp{} in the first release.}
\label{fig:hephaestus-conf1a}
\end{center}
\end{figure*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure*}[bth]
\begin{center}
\includegraphics[scale=0.6]{imagens/conf1b-hp.png}
\caption{Configuration of \hp{} in the second release.}
\label{fig:hephaestus-conf1b}
\end{center}
\end{figure*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In order to achieve these goals, new data types and transformations
were required, as well as part of the existing code had to
change. Precisely, to introduce support for variabilities in
high-level requirements (or requirements for short) and source code,
the following implementation and evolution steps were necessary:

\begin{enumerate}[(a)]

\item Implementation of new data types for representing requirements
  and references to source code assets.

\item Implementation of new parsing and output functions for
  reading/writing requirements and source code assets into/from \hp.

\item Implementation of new transformations for resolving
  variabilities in requirements and source code.

\item Evolution of the configuration knowledge XML parser so that it
  could recognize the concrete syntax of the new transformations.

\item Evolution of the base product instance used by the \texttt{build}
  function.

\item Evolution of both, \texttt{SPLModel} and \texttt{InstanceModel}
  data types, to collect new assets.

\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
\begin{lstlisting}
data SPLModel = SPLModel { *'\label{splmodel-i-2}'*
   splFeatureModel :: FeatureModel,
   splUCM :: UseCaseModel,
   splReq :: RequirementModel,
   splComponents :: ComponentModel *'\label{splComponents-2}'*
} *'\label{splmodel-f-2}'*

data InstanceModel = InstanceModel { *'\label{instancemodel-i-2}'*
   featureConfiguration :: FeatureConfiguration,
   ucm :: UseCaseModel,
   req :: RequirementModel,
   components :: ComponentModel, *'\label{components-2}'*
   buildEntries :: [PreprocessingDirective], *'\label{buildEntries-2}'*
   preProcessFiles :: [PreprocessingFiles] *'\label{preProcessFiles-2}'*
} *'\label{instancemodel-f-2}'*

build :: FeatureModel -> FeatureConfiguration 
      -> ConfigurationKnowledge -> SPLModel -> InstanceModel
build fm fc ck spl = derive ts spl emptyInstance
where
    ts = concat [transformations c | c <- ck, eval fc (expression c)]
    ucmodel       = splUCM spl
    emptyUCM      = ucmodel { useCases = [] , aspects = [] }  *'\label{emptyInstance-i-2}'*
    emptyReq      = RM { reqs = [] }
    emptyInstance = InstanceModel fc emptyUCM emptyReq [] [] [] *'\label{emptyInstance-f-2}'*

exportProduct :: FilePath -> FilePath -> InstanceModel -> IO ()  *'\label{exportP-i-2}'*
exportProduct s o product = do
  exportUcmToLatex (o ++ ``/doc.tex'') (ucm product)
  exportRequirementsToLatex (o ++ ``/doc.lst'') (req product)
  exportSourceCode s o product  *'\label{exportP-f-2}'*

exportRequirementsToLatex :: FilePath -> RequirementModel -> IO ()
exportSourceCode o rm = ...

exportSourceCode :: FilePath -> FilePath -> InstanceModel -> IO ()
exportSourceCode s o p = ...
\end{lstlisting}
\caption{\texttt{SPLModel} and \texttt{InstanceModel} data types, \texttt{emptyInstance} definition and \texttt{exportProduct} function
  after introducing support for managing variabilities in requirements and source code}
\label{fig:spl-model-with-req-and-code}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The evolution of data types and functions of \hp{}, as described
above, is illustrated in Figures~\ref{fig:spl-model-with-req-and-code}
and~\ref{fig:xml-transformation-parser}. To introduce support for new
types of assets, we have to change the \texttt{SPLModel} data type (lines
\ref{splmodel-i-2}-\ref{splmodel-f-2} in
Figure~\ref{fig:spl-model-with-req-and-code}), the
\texttt{InstanceModel} data type (lines
\ref{instancemodel-i-2}-\ref{instancemodel-f-2}), the empty
product definition (lines
\ref{emptyInstance-i-2}-\ref{emptyInstance-f-2}), the
\texttt{exportProduct} function (lines
\ref{exportP-i-2}-\ref{exportP-f-2}), and the
\texttt{xml2Transformation} function of the XML parser for configuration knowledge
(Figure~\ref{fig:xml-transformation-parser}).

In contrast, the data types \texttt{ConfigurationKnowledge} and
\texttt{FeatureModel} as well as the interpreter (\texttt{build}
function) do not require any revision, when we introduce variability
support for new assets. 

In particular, evolving \hp{} to support source code variability
(Figure~\ref{fig:spl-model-with-req-and-code}) required a new kind of
asset into the \texttt{SPLModel} (\texttt{splComponents}, line
\ref{splComponents-2}). This asset is a list of pairs that relate a
name to the relative path of a source code file. The same kind of
asset was also introduced into the \texttt{InstanceModel} (line
\ref{components-2}). Besides that, two other fields were required in
the InstanceModel: (a) \texttt{buildEntries} (line
\ref{buildEntries-2}), which declares pre-processing directives, and
(b) \texttt{preProcessFiles} (line \ref{preProcessFiles-2}), which
declares a list of files that should be pre-processed by a third part
tool. These fields are instantiated when \hp{} builds a product,
considering the proper transformations of a product configuration.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
\begin{lstlisting}
xml2Transformation :: XmlTransformation -> Parser Transformation
xml2Transformation transformation =
let
  args = ...
  tnsName = xmlTransformationName transformation
in
  case tnsName of
   "selectScenarios" -> Success (selectScenarios args) *'\label{transformations-ucm-i-2}'*
   "selectUseCases" -> Success (selectUseCases args)
   "evaluateAspects" -> Success (evaluateAspects args)
   "bindParameter" -> ...  *'\label{transformations-ucm-f-2}'*
   "selectRequirements" -> ... *'\label{transformations-req-2}'*
   "selectComponents" -> ... *'\label{transformations-code-i-2}'*
   "selectAndMoveComponent" -> ...
   "createBuildEntries" -> ...
   "preprocessFiles" -> ... *'\label{transformations-code-f-2}'*
   _ -> Fail ``...''
\end{lstlisting}
\caption{Code snippet for the XML parser for configuration knowledge}
\label{fig:xml-transformation-parser}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The code snippet in Figure~\ref{fig:xml-transformation-parser} shows
the revised XML parser for configuration knowledge. The initial
version of \hp{} declared just the first four case statements on the
\texttt{xml2Transformation} function (lines
\ref{transformations-ucm-i-2}-\ref{transformations-ucm-f-2}). The
added \texttt{selectRequirements} transformation (line
\ref{transformations-req-2}) deals with variability in the
requirements models, whereas the remaining transformations (lines
\ref{transformations-code-i-2}-\ref{transformations-code-f-2}) deal
with variability in source code. 

Likewise, \hp{} also provides limited configurability: to obtain a new
version of \hp{} managing variability in only a proper subset of the
artifacts currently supported (use cases, requirements, code), e.g., a
version supporting only code and use cases, the change impact is
similar to what has been described previously when adding new assets.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\hp's `Expression Problem'}
\label{S:xp}

Technically, the evolution scenario demonstrated an extensibility
problem. We had to extend data types and functions to incorporate new
artifacts, transformations, and support functionality (e.g., for
exporting). We failed to provide a modular extension; instead, we had
to properly revise existing code.

The well-known `Expression Problem'
(EP~\cite{Wadler98,Lopez-HerrejonBC05}) captures this sort of
challenge in a principle manner: \emph{Given a family of data variants
  and a family of operations on the data, how do can design an
  implementation of data and operations such that new variants and new
  operations can be added without revising existing code, while
  possibly also providing some degree of separate compilation, modular
  type checking, and modular reasoning?}

Hinze and L\"oh proposed a Haskell extension for open data types and
functions for Haskell~\cite{LoehH06}, which would provide a solution
to the EP in Haskell. The extension allows adding new cases to data
types and new equations to functions, but it does not deal with
additional adaptation patterns encountered in
Figure~\ref{fig:spl-model-with-req-and-code}. Specifically, the
evolution of \hp{} also involved extending `products' (see the data
types \texttt{SPLModel} and \texttt{InstanceModel}) and `function
compositions' (see the the function \texttt{exportProduct}).
Arguably, these adaptation patterns could be eliminated by using a
different data and program design that treats the products instead as
more generic containers. Ultimately, the extension in not available in
actual Haskell systems.

L\"ammel and Ostermann proposed a type class-based encoding for
solving the EP in Haskell with established extensions (in fact, in
Haskell~98 for the narrow EP)~\cite{LaemmelO06}. This approach is not
applied for several reasons. Firstly, the encoding overhead would be
substantial. Data types like \texttt{SPLModel} and
\texttt{InstanceModel} and functions like \texttt{exportProduct} and
\texttt{xml2Transformation} would need to be represented as type
classes, their constructors and equations would give rise to extra
data types and type-class instances, leading to a substantial increase
in code size and a negative impact on programmability due to more
complex type-error messages. Secondly, the approach also fails at the
aforementioned adaptation patterns, which go beyond the EP. Thirdly,
and more subtly, the approach also fails a function extension
scenarios that are not readily based on different constructors; see 
\texttt{xml2Transformation}, where all equations match on strings.

Importantly, both approaches share a lack of managing variability
explicitly. The engineer, who derives a SPL, would need to engage in
programming activities of importing modules appropriately, without a
clear mapping to a feature model of a product line for tools for SPL
derivation.

Consequently, we decided to provide extensibility by means of
metaprograms on top of object programs in standard Haskell (Haskell~98
in the case of \hpl). The approach effectively supports extensible
data types (both sums and products) and extensible functions (both
adding equations and extending equations for the relevant idioms).
The metaprogramming approach does not only provide the necessary
extensibility, it can also be easily used with a SPL-like approach for
variable management because the metaprogramming transformations can be
represented by configuration knowledge. \hpl{} is modularized in a way
that metaprogramming only affects those few abstractions that require
configurability, flexibility, and extensibility. Most assets are
separately compilable and will not be affected by metaprograms.
Finally, the metaprogramming approach also enables bootstrapping of
\hpl.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
