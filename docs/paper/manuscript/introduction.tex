%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Context: SPL derivation tools

A \emph{Software Product Line} (SPL) is a set of software-intensive systems that share a common, managed set of features satisfying the specific needs of a particular domain, market segment, or mission and that are developed from a common set of core assets in a prescribed way~\cite{spl-book}. Potential benefits include improved productivity with lower development costs and time-to-market and increased quality. To achieve these benefits, tool support for the underlying activities is essential. In particular, this holds for \emph{application engineering}, in which a product is defined by selecting a group of features and then parts of different components are combined. Given the inherent complexity of SPLs and the coordination required for application engineering, the process of derivation of individual products from shared software assets should be supported by tools: \emph{product derivation tools}. Without such tools, the derivation process is a laborious, error-prone, and thus, expensive activity~\cite{griss,deelstra:2005}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Problem:

The changing needs of users and the continuous evolution of product lines motivates configurability and extensibility of product derivation tools for addressing future needs. As reported by a contemporary, systematic literature review and expert survey~\cite{ist-2010}, key requirements of product derivation tools are indeed configurability and extensibility (in fact, `flexibility' in the terminology of~\cite{ist-2010}) which the same study identifies as shortcoming of most existing tools. The present paper addresses such configurability and extensibility. As an illustration of insufficient configurability, consider a derivation tool that targets different types of assets without supporting, though, the selection of types for a specific use case of the tool. For instance, different variants of the Haskell-based \hp{} tool~\cite{rbonifacio:sbcars2009} for product derivation target use case models, requirement models, source code, and yet other types of assets, but the selection of only some of the types is not possible for a given variant of \hp. The present paper studies \hp{} in detail and improves it ultimately. As an illustration of insufficient extensibility, consider a derivation tool that needs to target an additional type of asset without providing, though, any extension scheme and process to this end. For instance, \hp{} had to target architectural models at some point, but this extension could only be completed in a low-level (i.e., laborious and error-prone) manner.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Challenge

The requested configurability and extensibility may be obtainable, if variability within tools for product derivation is managed by architecting the tools themselves as SPLs, as suggested by Gr{\"u}nbacher et al.~\cite{grunbacher:2008} and also exemplified by some efforts~\cite{grunbacher:2011,batory-ahead-bootstrap}. Overall, the major contribution of the present paper is the description of the details of the engineering process for obtaining and enhancing such a meta-product line, while using the Haskell-based \hp{} tool for product derivation for a comprehensive study.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection*{Contributions of the Paper}

Overall, we provide strong evidence for the feasibility of configurable and extensible tools for product derivation. More specifically:

\begin{itemize}

\item We describe an extractive process that enhances the existing Haskell-based tool \hp{} for deriving products from a SPL into a Haskell-based proper product line, \hpl, for product derivation tools. In particular, we describe domain analysis, design, and implementation~\cite{gpbook} of \hpl. Configuration is expressive; specifically, or-features (allowing for combinations) are supported as opposed to just alternative features (allowing only for exclusive choices). \hpl{} employes a general, transformational approach to variable management.

\item We describe the technicalities and implications of providing a meta-SPL in Haskell. \hpl's transformational approach is implemented through metaprogramming in Haskell. Technically, we had to solve an \hp-specific variation on the `Expression Problem'~\cite{Wadler98,Lopez-HerrejonBC05} within Haskell. The approach enables modular code organization for all components of \hpl, separate compilation within limits, and bootstrapping of \hpl, thereby achieving high uniformity across the regular SPL level and the meta-SPL level.

\item We describe a reactive process for evolving \hpl{} such that it models variability for new types of assets so that product line tools can be derived for these new types. An assessment reveals that \hpl{} has improved configurability and extensibility when compared to previous variants of \hp. In this manner, the present paper provides evidence for the effectiveness of addressing the problem of configurable and extensible tools for product derivation.

\end{itemize}

To some extent, these contributions are specific to the chosen setup as far as the product line technology is concerned (\hp, \hpl), the kind of assets types covered, and variability mechanisms (with Haskell as implementation language and reliance on metaprogramming in Haskell) provided. We believe, though, that the contributions and experiences could be leveraged in other contexts in which configurability and extensibility of tools for product derivation are key requirements.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection*{Road-map of the Paper}

The remainder of this paper is organized as follows. First, Section~\ref{sec:hephaestus} briefly describes \hp{} and analyzes a representative evolution scenario for addressing an additional type of asset. Next, based on experience with variants and evolution history of \hp, Section~\ref{sec:domainAnalysis}--\ref{sec:implementation} describe 
domain analysis, domain design, and implementation of \hpl. Section~\ref{sec:process} describes a reactive process for extending \hpl. Section~\ref{sec:assessment} provides an assessment \hpl{} based on the GQM method. Related work is addressed in Section~\ref{related-work}. The paper is concluded in Section~\ref{conclusion}. 

The Haskell source code of \hpl{} is publically available.\footnote{\url{https://gitorious.org/hephaestus-pl/hephaestus-pl}} For the rest of the paper, `Haskell' refers to standardized Haskell in sense of Haskell 2012\footnote{\url{http://www.haskell.org/onlinereport/haskell2010/}}, unless noted otherwise.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
