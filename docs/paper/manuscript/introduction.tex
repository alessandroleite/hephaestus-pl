\section{Introduction}
\label{introduction}

% *context:
%    - SPL derivation tools
A Software Product Line (SPL) is a set of software intensive systems that share a common, managed set of features satisfying the specific needs of a particular market segment or mission and that are developed from a common set of core assets in a prescribed way~\cite{spl-book}. Potential benefits include improved productivity with lower development costs and time-to-market and increased quality. To achieve these, tool support for its underlying activities is essential. In particular, this holds for Application Engineering, in which a product is defined by selecting a group of features and then a carefully coordinated mixture of parts of different components are involved. Given the inherent complexity and the coordination required in the derivation process~\cite{griss}, this activity is slow and error-prone. As a result, the derivation of individual products from shared software assets is still a time-consuming and expensive activity in many organizations~\cite{deelstra:2005}.


% **problem**:
%  - lack of configurability and flexibility  |
%  - absence of systematic handling of variability of tools>>

As reported by a contemporary Systematic Literature Review and expert survey~\cite{ist-2010},  key requirements of product derivation tools are configurability and flexibility, which the same study identifies as shortcoming of most existing tools. Indeed, these must be adapted to different contexts, e.g., dealing with any combination of different artifacts. For instance, each different tool configuration could support a specific combination of business process, code, and requirement artifacts. Additionally, the changing needs of users and the continuous evolution of the product line further motivate flexibility and configurability of product derivation tools for addressing future needs, e.g., dealing with new artifacts such as architectural models. Further, without a supporting process, dealing with such variability drivers is not effective.

% **solution**
% - development of Hephaestus-PL (analysis, design, implementation)
% - reactive (evolution) process
Therefore, to provide configurability and flexibility, it becomes necessary to adequately manage the variability within these tools, addressing the tools themselves as SPLs, as also suggested by Gr{\"u}nbacher et al.~\cite{grunbacher:2008}. Despite existing effort in this
direction~\cite{grunbacher:2011,grunbacher:2008,batory-ahead-bootstrap}, focus on managing variability in new different artifacts and in any combination of these is not addressed. Further, detailed domain analysis, design, implementation, and a supporting process are not provided neither are publicly available.
% is the last phrase relevant for the problem we have at hand? just delete it for now
%Finally, to best of our knowledge, there is no such effort involving infrastructure based in functional languages.
%TODO: insert link to Hephaestus-PL web site
Accordingly, the contribution of this paper is twofold by presenting the following:

\begin{itemize}
  \item domain analysis, design, and implementation of \hpl, a flexible and configurable software product line of software product line tools;
  \item a process for evolving \hpl{} to address new artifacts.
\end{itemize}

The first contribution deals with the feasibility of addressing the problem. In particular, \hpl{} is publicly available  and has been developed by managing commonality and variability from existing variants of \hp~\cite{rbonifacio:sbcars2009}, a SPL tool developed in Haskell and originally aimed at managing variability in use case scenarios, but which has evolved to handle variability independently in different kinds of artifacts (a detailed description of \hp, including usage scenarios can be found elsewhere~\cite{rbonifacio:sbcars2009}). \hpl's design is centered around bootstrapping--with a kernel representing the key common elements of the existing \hp{} variants--and whose variability management was implemented using metaprogramming in Haskell. The second contribution refers to the effectiveness of addressing the problem: \hpl{} is supported by a process allowing instantiating product line tools for modeling variability in new artifacts (e.g., business process, use case scenarios, code). An assessment reveals that \hpl{} has improved configurability and flexibility when compared to previous evolution of Hephaestus. We believe that these contributions could be leveraged to other contexts in which configurability and flexibility of product lines are key requirements.


%Accordingly, this paper presents domain analysis, design, implementation, and a supporting process of \hpl, a publicly available (?) software product line of software product line tools.  \hpl is supported by a process allowing instantiating product line tools for modeling variability in new and in any combination of artifacts (e.g., business process, use case scenarios, code), and has been developed by managing commonality and variability from existing variants of \hp~\cite{rbonifacio:sbcars2009}, a SPL tool developed in Haskell and originally aimed at managing variability in requirements, but which has evolved to handle variability independently in different kinds of artifacts (a detailed description of \hp, including usage scenarios can be found elsewhere~\cite{rbonifacio:sbcars2009}). \hpl's design is centered around bootstrapping--with a kernel representing the key elements of the existing \hp variants--and implemented using meta programming in Haskell. An assessment reveals that \hpl has improved configurability and flexibility when compared to previous evolution of Hephaestus.

% * paper organization
The remainder of this paper is organized as follows. First, Section~\ref{sec:hephaestus} briefly describes \hp{} and its evolution to address different artifacts. Next, based on such versions of \hp, Sections~\ref{sec:domainAnalysis} and~\ref{sec:domainDesign} presents the domain analysis and design of \hpl, respectively, whereas its implementation is explained in Section~\ref{sec:implementation}. Section~\ref{sec:process} then presents a supporting process for extending \hpl, and  Section~\ref{sec:results-discussion} provides an assessment and discussion of \hpl. Related work is addressed in Section~\ref{related-work}, and Section~\ref{conclusion} offers concluding remarks.


