%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{\hp{} SPL Asset} 
\label{hp-spl-asset}

This element declares algebraic data types representing \hp{} SPL asset, which just corresponds to a list of Haskell modules and the set of transformations for managing \hpl{} variability (code snippet in Figure~\ref{fig:code-hp-spl-asset}). In essence, these transformations are responsible for the refinement of the base product during derivation of the \hpl{} instance. In addition, this module also declares the \texttt{transformHpl} function which is responsible for actually performing the corresponding \hpl{} transformations and it has the same signature of \texttt{transform} function declared in the \hp{} product described in Section~\ref{hp-product}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\subsubsection{SPL Assets} 
\label{spl-assets}

Define the artifacts for each SPL asset, i.e., the algebraic data types representing a SPL asset, the set of transformations for solving asset's variability and the parser function to convert the external format into algebraic data types defined to \hpl.

In addition, this module also needs to define a data type and a function that comprising all asset's transformations to be used in \texttt{transform} function in the refinement of the base product when the asset is selected, for example, \texttt{UseCaseTransformation} data type and \texttt{transformUcm} function to the \texttt{Use Case} asset. The \texttt{transformUcm} function must have the same signature of \texttt{transform} function declared in the base product described in Section~\ref{base-product}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
\begin{lstlisting}
data HephaestusModel = HephaestusModel [HsModule]

data HephaestusTransformation = SelectBase
                              | SelectAsset String
                              | SelectExport String
                              | BindProductName String
                              | RemoveProductMainFunction
                              | SelectCKParser

transformHpl :: HephaestusTransformation
             -> SPLModel
             -> InstanceModel
             -> InstanceModel
\end{lstlisting}
\caption{Code snippet of the Hephaestus SPL Asset}
\label{fig:code-hp-spl-asset}
\end{figure}



 by extending the \texttt{ExportModel} data type, the \texttt{lstExport} list definition and the \texttt{export} function. Furthermore, it incorporates the module implementing the selected output format function into the product being derived. We define different transformations as \texttt{SelectAsset} and \texttt{SelectExport} to represent the refinement on the base product because the set of metaprogramming operations associated with each of these \hpl{} transformations is different and independent.


Although these patterns involve scattering and tangling, a compositional approach (e.g., AOP) does not meet the expressiveness requirement given the heterogeneity in granularity. With this transformational approach, 1) configurability is addressed by enabling \hpl{} with an automatic support to generate product instances with different combinations of assets; 2) extensibility is guaranteed by \hpl{}'s architectural design allowing support to variability management of different assets, independence between the assets and mostly no impact on kernel when inserting new assets in \hpl.

Consequently, we decided to provide extensibility by means of
metaprograms on top of object programs in standard Haskell (Haskell~98
in the case of \hpl). The approach effectively supports extensible
data types (both sums and products) and extensible functions (both
adding equations and extending equations for the relevant idioms).
The metaprogramming approach does not only provide the necessary
extensibility, it can also be easily used with a SPL-like approach for
variable management because the metaprogramming transformations can be
represented by configuration knowledge. Finally, the
metaprogramming approach also enables bootstrapping of \hpl.